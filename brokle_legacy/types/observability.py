"""
Observability domain models matching the ClickHouse backend.

This module defines the core entities for the observability system:
- Traces: Complete operation traces with hierarchy and session support
- Observations: Spans/events/generations within a trace
- Scores: Quality evaluation scores
- Sessions: User journey grouping multiple traces

All entities use ULID (26-character strings) for identifiers and support
the immutable event pattern with ReplacingMergeTree updates via versioning.
"""

from datetime import datetime, timezone
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator


class ObservationType(str, Enum):
    """
    Observation types.

    - LLM: Legacy type for LLM calls (deprecated in favor of GENERATION)
    - GENERATION: LLM text generation
    - SPAN: Generic operation span
    - EVENT: Point-in-time event
    - RETRIEVAL: Document/context retrieval
    - EMBEDDING: Text embedding generation
    - AGENT: Agent execution
    - TOOL: Tool/function call
    - CHAIN: Chain of operations
    """
    LLM = "LLM"
    GENERATION = "GENERATION"
    SPAN = "SPAN"
    EVENT = "EVENT"
    RETRIEVAL = "RETRIEVAL"
    EMBEDDING = "EMBEDDING"
    AGENT = "AGENT"
    TOOL = "TOOL"
    CHAIN = "CHAIN"


class ObservationLevel(str, Enum):
    """
    Observation severity/logging level matching backend exactly.

    - DEBUG: Detailed debugging information
    - INFO: Informational messages
    - WARN: Warning condition
    - ERROR: Error condition
    - DEFAULT: Normal operation (default)
    """
    DEBUG = "DEBUG"
    INFO = "INFO"
    WARN = "WARN"
    ERROR = "ERROR"
    DEFAULT = "DEFAULT"


class ScoreDataType(str, Enum):
    """
    Score value data type.

    - NUMERIC: Float value (stored in 'value' field)
    - CATEGORICAL: String value (stored in 'string_value' field)
    - BOOLEAN: Boolean stored as 1.0/0.0 in 'value' field
    """
    NUMERIC = "NUMERIC"
    CATEGORICAL = "CATEGORICAL"
    BOOLEAN = "BOOLEAN"


class ScoreSource(str, Enum):
    """
    Score source type matching backend exactly.

    - API: Programmatically submitted via API
    - AUTO: Automatically generated by system
    - HUMAN: Human review/annotation
    - EVAL: Automated evaluation
    """
    API = "API"
    AUTO = "AUTO"
    HUMAN = "HUMAN"
    EVAL = "EVAL"


class Trace(BaseModel):
    """
    Complete operation trace with hierarchy and session support.

    Traces represent top-level operations (e.g., user queries, workflows) and can
    contain multiple observations (LLM calls, tool calls, etc.).

    Attributes:
        id: ULID identifier (26 chars) - generated client-side
        project_id: Project ULID - set by backend from API key
        session_id: Optional session ULID for grouping traces
        parent_trace_id: Optional parent trace for hierarchical traces
        name: Human-readable trace name
        user_id: Optional user ULID
        timestamp: Trace start timestamp
        input: Optional input data as dict
        output: Optional output data as dict
        metadata: String key-value metadata (indexed in ClickHouse)
        tags: List of tags for filtering
        environment: Environment tag (e.g., "production", "staging")
        release: Optional release version
    """

    # Identifiers
    id: str = Field(..., description="ULID identifier (26 chars)", min_length=26, max_length=26)
    project_id: Optional[str] = Field(None, description="Project ULID (set by backend)")
    session_id: Optional[str] = Field(None, description="Session ULID for grouping traces")
    parent_trace_id: Optional[str] = Field(None, description="Parent trace ULID for hierarchy")

    # Basic information
    name: str = Field(..., description="Human-readable trace name")
    user_id: Optional[str] = Field(None, description="User ULID")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Trace start timestamp")

    # Data (will be serialized to JSON strings in backend)
    input: Optional[Dict[str, Any]] = Field(None, description="Input data")
    output: Optional[Dict[str, Any]] = Field(None, description="Output data")

    # Metadata and tags
    metadata: Dict[str, str] = Field(default_factory=dict, description="String key-value metadata")
    tags: List[str] = Field(default_factory=list, description="Tags for filtering")

    # Environment and versioning
    environment: Optional[str] = Field(None, description="Environment tag", max_length=40)
    release: Optional[str] = Field(None, description="Release version")

    @field_validator('id', 'session_id', 'parent_trace_id', 'user_id', 'project_id')
    @classmethod
    def validate_ulid(cls, v: Optional[str]) -> Optional[str]:
        """Validate ULID format (26 chars, Crockford's base32)."""
        if v is None:
            return v
        if len(v) != 26:
            raise ValueError(f"ULID must be exactly 26 characters, got {len(v)}")
        # ULID uses Crockford's base32: 0-9, A-Z excluding I, L, O, U
        valid_chars = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        if not all(c in valid_chars for c in v.upper()):
            raise ValueError(f"ULID contains invalid characters: {v}")
        return v


class Observation(BaseModel):
    """
    Span/event/generation within a trace.

    Observations represent individual operations within a trace (LLM calls, tool calls,
    embeddings, etc.) and can be nested via parent_observation_id.

    Attributes:
        id: ULID identifier (26 chars) - generated client-side
        trace_id: Parent trace ULID
        parent_observation_id: Optional parent observation ULID for nesting
        project_id: Project ULID - set by backend from API key
        type: Observation type (LLM, GENERATION, SPAN, etc.)
        name: Human-readable observation name
        start_time: Observation start timestamp
        end_time: Optional observation end timestamp
        model: Optional model identifier (e.g., "gpt-4", "claude-3-opus")
        model_parameters: Model configuration as string key-value pairs
        input: Optional input data as dict
        output: Optional output data as dict
        metadata: String key-value metadata
        cost_details: Cost breakdown (keys: input, output, total - all in USD)
        usage_details: Token usage (keys: prompt_tokens, completion_tokens, total_tokens)
        level: Severity/logging level
        status_message: Optional status/error message
        completion_start_time: Optional timestamp when completion started (for streaming)
        time_to_first_token_ms: Optional time to first token in milliseconds
    """

    # Identifiers
    id: str = Field(..., description="ULID identifier (26 chars)", min_length=26, max_length=26)
    trace_id: str = Field(..., description="Parent trace ULID", min_length=26, max_length=26)
    parent_observation_id: Optional[str] = Field(None, description="Parent observation ULID")
    project_id: Optional[str] = Field(None, description="Project ULID (set by backend)")

    # Observation metadata
    type: ObservationType = Field(..., description="Observation type")
    name: str = Field(..., description="Human-readable observation name")
    start_time: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Start timestamp")
    end_time: Optional[datetime] = Field(None, description="End timestamp")

    # Model information
    model: Optional[str] = Field(None, description="Model identifier")
    model_parameters: Dict[str, str] = Field(default_factory=dict, description="Model configuration")

    # Data (will be serialized to JSON strings in backend)
    input: Optional[Dict[str, Any]] = Field(None, description="Input data")
    output: Optional[Dict[str, Any]] = Field(None, description="Output data")
    metadata: Dict[str, str] = Field(default_factory=dict, description="String key-value metadata")

    # Cost tracking (keys: input, output, total - all in USD)
    cost_details: Dict[str, float] = Field(default_factory=dict, description="Cost breakdown in USD")

    # Token usage (keys: prompt_tokens, completion_tokens, total_tokens)
    usage_details: Dict[str, int] = Field(default_factory=dict, description="Token usage")

    # Status and logging
    level: ObservationLevel = Field(default=ObservationLevel.DEFAULT, description="Severity level")
    status_message: Optional[str] = Field(None, description="Status/error message")

    # Completion tracking for streaming responses
    completion_start_time: Optional[datetime] = Field(None, description="Completion start timestamp")
    time_to_first_token_ms: Optional[int] = Field(None, description="Time to first token (ms)", ge=0)

    @field_validator('id', 'trace_id', 'parent_observation_id', 'project_id')
    @classmethod
    def validate_ulid(cls, v: Optional[str]) -> Optional[str]:
        """Validate ULID format (26 chars, Crockford's base32)."""
        if v is None:
            return v
        if len(v) != 26:
            raise ValueError(f"ULID must be exactly 26 characters, got {len(v)}")
        valid_chars = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        if not all(c in valid_chars for c in v.upper()):
            raise ValueError(f"ULID contains invalid characters: {v}")
        return v


class Score(BaseModel):
    """
    Quality evaluation score.

    Scores can be attached to traces, observations, or sessions for quality evaluation.
    At least one of trace_id, observation_id, or session_id must be set.

    Attributes:
        id: ULID identifier (26 chars) - generated client-side
        project_id: Project ULID - set by backend from API key
        trace_id: Optional trace ULID
        observation_id: Optional observation ULID
        session_id: Optional session ULID
        name: Score name/metric (e.g., "accuracy", "quality", "relevance")
        value: Numeric value (for NUMERIC and BOOLEAN types)
        string_value: String value (for CATEGORICAL type)
        data_type: Score data type (NUMERIC, CATEGORICAL, BOOLEAN)
        source: Score source (API, SDK, HUMAN, EVAL)
        comment: Optional comment/explanation
        evaluator_name: Optional evaluator identifier
        evaluator_version: Optional evaluator version
        evaluator_config: Evaluator configuration as string key-value pairs
        author_user_id: Optional author user ULID (for HUMAN source)
        timestamp: Score timestamp
    """

    # Identifiers (at least one of trace_id, observation_id, session_id must be set)
    id: str = Field(..., description="ULID identifier (26 chars)", min_length=26, max_length=26)
    project_id: Optional[str] = Field(None, description="Project ULID (set by backend)")
    trace_id: Optional[str] = Field(None, description="Trace ULID")
    observation_id: Optional[str] = Field(None, description="Observation ULID")
    session_id: Optional[str] = Field(None, description="Session ULID")

    # Score data
    name: str = Field(..., description="Score name/metric")
    value: Optional[float] = Field(None, description="Numeric value")
    string_value: Optional[str] = Field(None, description="String value (for CATEGORICAL)")
    data_type: ScoreDataType = Field(default=ScoreDataType.NUMERIC, description="Score data type")

    # Source and metadata
    source: ScoreSource = Field(default=ScoreSource.API, description="Score source")
    comment: Optional[str] = Field(None, description="Comment/explanation")

    # Evaluator information
    evaluator_name: Optional[str] = Field(None, description="Evaluator identifier")
    evaluator_version: Optional[str] = Field(None, description="Evaluator version")
    evaluator_config: Dict[str, str] = Field(default_factory=dict, description="Evaluator configuration")

    # Author tracking (for HUMAN source)
    author_user_id: Optional[str] = Field(None, description="Author user ULID")

    # Timestamp
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Score timestamp")

    @field_validator('id', 'project_id', 'trace_id', 'observation_id', 'session_id', 'author_user_id')
    @classmethod
    def validate_ulid(cls, v: Optional[str]) -> Optional[str]:
        """Validate ULID format (26 chars, Crockford's base32)."""
        if v is None:
            return v
        if len(v) != 26:
            raise ValueError(f"ULID must be exactly 26 characters, got {len(v)}")
        valid_chars = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        if not all(c in valid_chars for c in v.upper()):
            raise ValueError(f"ULID contains invalid characters: {v}")
        return v


class Session(BaseModel):
    """
    User journey grouping multiple traces.

    Sessions group related traces together (e.g., a chat conversation, workflow execution).

    Attributes:
        id: ULID identifier (26 chars) - generated client-side
        project_id: Project ULID - set by backend from API key
        user_id: Optional user ULID
        metadata: String key-value metadata
        bookmarked: Whether session is bookmarked
        public: Whether session is publicly accessible
        created_at: Session creation timestamp
    """

    # Identifiers
    id: str = Field(..., description="ULID identifier (26 chars)", min_length=26, max_length=26)
    project_id: Optional[str] = Field(None, description="Project ULID (set by backend)")
    user_id: Optional[str] = Field(None, description="User ULID")

    # Session metadata
    metadata: Dict[str, str] = Field(default_factory=dict, description="String key-value metadata")

    # Feature flags
    bookmarked: bool = Field(default=False, description="Bookmarked flag")
    public: bool = Field(default=False, description="Public accessibility flag")

    # Timestamps
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc), description="Creation timestamp")

    @field_validator('id', 'project_id', 'user_id')
    @classmethod
    def validate_ulid(cls, v: Optional[str]) -> Optional[str]:
        """Validate ULID format (26 chars, Crockford's base32)."""
        if v is None:
            return v
        if len(v) != 26:
            raise ValueError(f"ULID must be exactly 26 characters, got {len(v)}")
        valid_chars = "0123456789ABCDEFGHJKMNPQRSTVWXYZ"
        if not all(c in valid_chars for c in v.upper()):
            raise ValueError(f"ULID contains invalid characters: {v}")
        return v


__all__ = [
    "ObservationType",
    "ObservationLevel",
    "ScoreDataType",
    "ScoreSource",
    "Trace",
    "Observation",
    "Score",
    "Session",
]
